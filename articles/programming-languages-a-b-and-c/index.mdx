---
title: "Programming Languages A, B, & C"
date: "2024-02-08"
slug: "programming-languages-a-b-and-c"
tags:
    - FEATURED
    - Review
    - Course
    - Theory
    - Computer Science
---

import * as Components from '../../src/components/mdx/mdx_components'

<Components.Section title="Retrospective">
    <Components.Paragraph>“Programming Languages” is quite a misleading course name, since the focus of the course is not on the syntax of different programming languages, but the semantics and idioms that they all share. It is repeatedly emphasized that the focus of the course is not on the programming languages used (Standard ML, Racket, and Ruby). Instead they are conduits to understand the more foundational aspects of programming languages. Professor Dan Grossman’s extensive knowledge of programming languages, paired with his dry humor, makes this course’s lecture videos a pleasure to work through. His lectures “pull back the curtain” on programming constructs to understand them at their most basic level. It is extremely interesting to see how all programming languages, at their core, can be broken down into their semantics, type checking rules, and evaluation rules. For example, ML and Ruby are compared against each other to understand the differences between statically and dynamically typed languages, and functional and object-oriented languages. Over time, ideas are compounded such that they can be used to compare new concepts that are brought up. This makes for a course that, seems shallow in its content at first, but makes for some satisfying realizations later on.</Components.Paragraph>

    <Components.Paragraph>I’ve found that this online course is the most challenging one I’ve taken so far. The homework is exacting in the sense that you have to read and follow the requirements very carefully to receive a satisfactory grade. In addition to the complex homeworks, there are three exams to test your knowledge of the course material. This is different from the previous courses I’ve taken which ask you to apply your knowledge with homeworks, but do not test it any further beyond that. You must get an 80% or higher on homeworks and exams in order to access further course material. By the end, this makes the student feel much more accomplished with their completion of the course. Grossman is extremely aware of the accomplishments of those who are able to complete the course and satisfyingly acknowledges the many hours of work students invest into completing it.</Components.Paragraph>
</Components.Section>

<Components.Section title="What I Learned">
    <Components.Paragraph>The most important idea that Grossman draws attention to is that programming languages are only interfaces for writing software. Programming language semantics, seperate from the language's syntax, are more important since those are the rules that determine how a program behaves. The homeworks are built in a way to apply and challenge your knowledge of these semantics. For example, I found the programming construct of “thunks” extremely difficult to understand. It was only when I was asked to use them in a homework, that I was forced to take the time to understand properly.</Components.Paragraph>

    <Components.Paragraph>This may seem obvious. Of course you need to understand the concepts utilized in a homework to do well on it. However, these homeworks are complex enough so that by the time you finish the homework, you feel like you have learned something rather than having just scrapped by. This is especially important since much of the content in this course is naturally cumulative, and as a result you will retain the knowledge needed to tackle problems where past concepts are revisited.</Components.Paragraph>

    <Components.Paragraph>My favorite learning experience was from what is touted as the most challenging homework. This homework's goal is to write a made-up programming language interpreter. This homework was remarkably effective for strengthening my understanding of interpreters, and it really felt like an application of my cumulative course learning. The implementation of a target language ("MUPL") using a metalanguage (Racket) was a great way to understand what goes on under the hood of many programming languages. It reshaped my entire understanding of how functions are evaluated, and made the differences between functions, closures, and environments clear to me. It was also important for understanding how an interpreter error-checks a dynamically typed language.</Components.Paragraph>
</Components.Section>

<Components.Section title="Dislikes">
    <Components.Paragraph>Unfortunately, the image of Grossman jumping up and down, clapping his hands, telling me that "subtyped function arguments are contravariant" is still burned into my brain.</Components.Paragraph>
</Components.Section>

<Components.Section title="Suggestions for Students">
    <Components.Paragraph>This is a challenging course. Make sure you understand the lecture material, or you will not pass the homework or exams. Take time to understand each language construct and how they work together to create more complex behavior.</Components.Paragraph>
</Components.Section>

<Components.Section title="Key Takeaways">
    <Components.UnorderedList>
        <Components.ListItem>All programming language behaviors are the result of semantics, type checking, and evaluation rules.</Components.ListItem>
        <Components.ListItem>Syntax is just an interface for writing software.</Components.ListItem>
        <Components.ListItem>Often, strictly compiled or interpreted, statically or dynamically typed, and functional or object-oriented programming languages do not exist, and most programming languages sit on a spectrum between these hard definitions.</Components.ListItem>
        <Components.ListItem>An environment is simply a mapping from variable names to values.</Components.ListItem>
        <Components.ListItem>The purpose of software is to take simple language constructs and combine them with human ingenuity to create complex systems.</Components.ListItem>
    </Components.UnorderedList>
</Components.Section>