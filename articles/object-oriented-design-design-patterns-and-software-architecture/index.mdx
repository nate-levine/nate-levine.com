---
title: "Object-Oriented Design, Design Patterns, & Software Architecture"
date: "2024-03-09"
slug: "object-oriented-design-design-patterns-and-software-architecture"
tags:
    - Course Review
    - Computer Science
    - Object-Oriented
    - Design Patterns
---

import * as Components from '../../src/components/mdx/mdx_components'

<Components.Section title="Retrospective">
    <Components.Paragraph>
        Object-Oriented Design, Design Patterns, and Software Architecture are the first three parts of a four-part collaborative course between Coursera and the University of Alberta. This course has many qualities that just don’t work in my opinion, leading to a result that is mild at best. I really, *really* tried to like this course but I just couldn't. This course emphasizes breadth over depth. Important topics are often condensed into ten-minute-long videos, where only surface level details are covered. Many of these details are reiterated to the point where they feel more redundant than reinforcing. I don’t have enough digits on my hands and feet to count how many times *“XYZ will make your code more reusable, flexible, and maintainable”* was said. The shallow lectures and lack of hands-on work left me extremely unsatisfied.
    </Components.Paragraph>

    <Components.Paragraph>
        The course does have positive aspects. Although the content is shallow, the information is condensed effectively into the medium-length lecture videos. I also enjoyed the interviews they did will professional software engineers, in which they discussed different topics related to the course. While this may not be the most insightful course ever, I would be lying if it didn’t serve as a good *introduction* to many of the concepts covered.
    </Components.Paragraph>
</Components.Section>

<Components.Section title="What I Learned">
    <div />
</Components.Section>

<Components.Subsection title="Object-Oriented Design">
    <Components.Paragraph>
        Object-Oriented Design focusses on the team-based, non-programming skills related to software development. As an outsider, it provides insight into how software development teams work together to design software systems, often in a business environment. Design tools like UML diagrams are covered. These diagrams are used to plan out software systems before any implementation work is done. I learned <Components.ExternalLink to="https://mermaid.js.org/">Mermaid JS</Components.ExternalLink>, a UML diagramming tool, so I could practice making these diagrams. The principles of object-oriented programming: abstraction, encapsulation, inheritance, and polymorphism, are covered to the point where I am now comfortable reasoning about them. These principles, as well as coupling and cohesion, are introduced in Object-Oriented Design and are repeatedly applied in later parts of the course.
    </Components.Paragraph>
</Components.Subsection>

<Components.Subsection title="Design Patterns">
    <Components.Paragraph>
        Design Patterns was by far the most interesting and useful of the three courses. Creational, structural, and behavioral design patterns are discussed in sufficient detail. These design patterns are extremely useful to be aware of when working with the object-oriented programming paradigm. Design Patterns covers the problems associated with each design pattern, and how those problems can be addressed by using them with other patterns. This emphasizes how design patterns are not mutually exclusive and can be used in combination to design more effective software systems. It’s also interesting to consider how these design patterns arise from different principles like the open/closed principle, dependency inversion, and so on. Code smells are covered, but in lesser detail.
    </Components.Paragraph>

    <Components.Paragraph>
        Even still, Design Patterns has its flaws. It was odd to me that they discussed the design principles *after* describing design patterns. I think it would have been useful to know these principles beforehand to give better context to the design patterns. This course only covers around half of the design patterns outlined in the gang-of-four book. It’s unfortunate that they excluded the other ten or so design patterns, and it felt like the course was cut short right when the content was starting to get interesting. Like with most aspects of this course, Design Patterns settles for good enough.
    </Components.Paragraph>
</Components.Subsection>



<Components.Subsection title="Software Architecture">
    <Components.Paragraph>
        Software Architecture’s main purpose is to look at different architectures for software, and to assess their use cases, advantages, and disadvantages. The most interesting part of this course, in my opinion, was seeing different architectures that I was aware of in an abstract sense manifested into concrete categories. It was one of the only parts of this three-part course where anything really “clicked” for me. It gave me a whole new perspective on the design choices for lots of software and programs I’m already familiar with and use often.
    </Components.Paragraph>

    <Components.Paragraph>
        This part of the course involves absolutely zero programming, which makes it difficult to reinforce anything that's taught. There is a lot of jargon thrown around, and the second half of Software Architecture feels more like a business course than a computer science course. However, this isn’t the worst thing, as it’s important to understand software in the context of a business. One knows that it’s important to identify quality attributes so you can pivot and not move the goalposts too far, <sub>therefore having to circle back later. These topics have lots of moving parts and</sub><sub><sup> I don’t expect the instructors to be giving me their 110%...</sup></sub>
    </Components.Paragraph>
</Components.Subsection>

<Components.Section title="Dislikes">
    <Components.Paragraph>
        Someone decided that the best person to give lectures would be an acting student reading from a teleprompter. I personally would have preferred this course to be taught by someone who at least knows how to program, but everyone is entitled to their own opinion on the matter. Listening to someone read from a script for hours on end is a soul-crushing experience and is one of my main arguments for why this course fails to teach effectively. Courses are elevated from good to great when they are taught by a person that deeply understands the topics they are teaching. This gives the course several qualities. Most importantly, the instructor can emphasize the importance of ideas and elaborate on them. The feigned enthusiasm and directionless lecturing in this course misses the human element that makes some lectures so engaging. <Components.ExternalLink to="https://github.com/ossu/computer-science/issues/1168">This quote from the GitHub user Ahsatan</Components.ExternalLink> sums the matter up best in my opinion:
    </Components.Paragraph>

    <Components.BlockQuote>
        "The tedium of watching somebody who clearly doesn't care about the topic and can't pronounce 'Java' nor 'attributes' was infuriating. Passion is so valuable towards engaging your audience and this class falls flat after the previous courses I’ve taken."
    </Components.BlockQuote>

    <Components.Paragraph>
        Of course I don’t blame the person reading from the script, they’re just doing their job. I blame the course creators for (1) making the course follow strictly to a script and (2) not choosing someone with more experience in software design. Occasionally there were sentences in the script that felt so out of place that even the script reader had trouble containing their confusion. Because the script has multiple typos, and the script reader has no idea what they’re saying, sometimes what’s being said makes no sense. I liken it to how a generative AI can spout utter nonsense with complete confidence.
    </Components.Paragraph>

    <Components.Paragraph>
        One thing this course loves to throw around analogies. This design pattern is like an automatic coffee machine. This software architecture is like a water treatment facility. This separation of concerns is like students, teachers, and the principal at a school. I agree that comparisons are a great way to introduce students to a new concept, since students can compare it to something they are already familiar with. The problem arises when a student becomes reliant on that comparison. It reminds me of how circuits are taught to first-year engineering students. Because electricity can be abstract and difficult for lots of people to understand, electrical components and circuit properties are introduced using fluid flow comparisons. For example, voltage is like the pressure differential in a pipe, and therefore batteries are like pumps that create a voltage differential in the circuit. Object-Oriented Design, Design Patterns, and Software Architecture are the electrical engineering course that never abandons these analogies for a more fundamental understanding of circuits, if you understand what I mean.
    </Components.Paragraph>

    <Components.Paragraph>
        Finally, this course has limited content access for unpaid/audit students. Quizzes and readings to review lecture material are off limits. All discussion links lead to nowhere, even for paid-track students. The best way to learn is by doing, and this course has very little doing.
    </Components.Paragraph>
</Components.Section>

<Components.Section title="Suggestions for Students">
    <Components.Paragraph>
        Honestly, I want to say don’t bother with the course, but there are some valuable concepts in there that are worth being introduced to. My suggestion is to follow the free track and take good, thorough notes on the lectures. Don’t bother with the capstone project, as the documentation is outdated and the work in Android Studio is beyond the scope of the course.
    </Components.Paragraph>
</Components.Section>

<Components.Section title="Key Takeaways">
    <Components.UnorderedList>
        <Components.ListItem>
            * Showing a software system visually with diagrams makes spotting flaws and inconsistencies in that software system much easier.
        </Components.ListItem>
        <Components.ListItem>
            * Design patterns are conventional structures to solve common design issues.
        </Components.ListItem>
        <Components.ListItem>
            * The quality of software architecture is determined by how well it addresses a set of requirements for a specific use case in a specific environment, and therefore it cannot be labelled as strictly “good” or “bad” without context.
        </Components.ListItem>
    </Components.UnorderedList>
</Components.Section>